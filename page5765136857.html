<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Thu Oct 05 08:07:09 UTC 2023 -->
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="combined.css"/>
    <link rel="stylesheet" href="custom.css"/>
    <script src="split/split.min.js"></script>
    <link rel="stylesheet" href="inline_styles.css"/>
</head>
<body>

<div class="full-height-container">
<div id="sidebar" class="split">
<div class="navgroup" id="search">
<form action="search.html" class="aui">
<input type="text" name="q" id="tipue_search_input" class="medium-field text">
<input class="button submit" type="submit" value="Search"></form>
</div>
<div class="navgroup" id="navigation">
<ul><li><span><a href="page5501091875.html">CLEAN CLIFcode Image</a></span></li><li><span><a href="page5766283265.html">TtDT - Report</a></span><input type="checkbox" checked/><ul><li><span><a href="page5765071213.html">TtDT - Report - Introduction</a></span></li><li><span><a href="page5769560149.html">TtDT - Report - A resilient approach</a></span></li><li><span><a href="page5766316210.html">TtDT - Report - A resilient, transparent bCLEARer pipeline architecture</a></span><input type="checkbox"/><ul><li><span><a href="page5773230168.html">TtDT - Report - bCLEARer's pipeline or pipe-and-filter architecture</a></span></li><li><span><a href="page5773656071.html">TtDT - Report - bCLEARer's nested gated pipeline architecture</a></span></li><li><span><a href="page5766545422.html">TtDT - Report - bCLEARer pipeline's three nesting levels</a></span></li><li><span><a href="page5775163422.html">TtDT - Report - bCLEARer pipeline - general design</a></span></li></ul></li><li><span><a href="page5769494532.html">TtDT - Report - Building resilient transformation transparency into the bCLEARer pipeline</a></span><input type="checkbox" checked/><ul><li><span>TtDT - Report - Building resilient dataset transformation transparency</span></li><li><span><a href="page5766316201.html">TtDT - Report - Building resilient data item transformation transparency</a></span></li></ul></li><li><span><a href="page5768675336.html">TtDT - Report - Appendices</a></span><input type="checkbox"/><ul><li><span><a href="page5769003012.html">TtDT - Report - Appendix - Process: principles versus rules</a></span></li><li><span><a href="page5768839184.html">TtDT - Report - Appendix - bH - bHashing and bSumming</a></span></li><li><span><a href="page5772804097.html">TtDT - Report - Appendix - cohesion and coupling</a></span></li><li><span><a href="page5772804106.html">TtDT - Report - Appendix - separation of concerns principle</a></span></li><li><span><a href="page5772869633.html">TtDT - Report - Appendix - immutability and idempotence principle</a></span></li><li><span><a href="page5772804114.html">TtDT - Report - Appendix - single-transformation (responsibility) principle (STP)</a></span></li><li><span><a href="page5773328385.html">TtDT - Report - Appendix - Aggregated S(ingle) S(ource) O(f) T(ruth)</a></span></li><li><span><a href="page5775982593.html">TtDT - Report - Appendix - design patterns and anti-patterns</a></span></li><li><span><a href="page5780340771.html">TtDT - Report - Appendix - Glossary of Major Terms</a></span><input type="checkbox"/><ul><li><span><a href="page5793284135.html">TtDT - Report - Appendix - Glossary of Major Terms - Report</a></span></li><li><span><a href="page5793218610.html">TtDT - Report - Appendix - Glossary of Major Terms - Research</a></span></li></ul></li><li><span><a href="page5784010894.html">TtDT - Report - Appendix - Reference Iconography</a></span><input type="checkbox"/><ul><li><span><a href="page5783355393.html">TtDT - Report - Appendix - Reference Iconography - Report</a></span><input type="checkbox"/><ul><li><span><a href="page5797249025.html">TtDT - Report - Appendix - Reference Iconography - Report - Pipeline architecture</a></span></li><li><span><a href="page5796298761.html">TtDT - Report - Appendix - Reference Iconography - Report - Life history</a></span></li><li><span><a href="page5796299378.html">TtDT - Report - Appendix - Reference Iconography - Report - Inter-diagram mapping</a></span></li><li><span><a href="page5796299991.html">TtDT - Report - Appendix - Reference Iconography - Report - Common</a></span></li></ul></li><li><span><a href="page5785092097.html">TtDT - Report - Appendix - Reference Iconography - Research</a></span><input type="checkbox"/><ul><li><span><a href="page5796331521.html">TtDT - Report - Appendix - Reference Iconography - Report - Pipeline architecture _ archive 30/01/23</a></span></li></ul></li></ul></li><li><span><a href="page5784338433.html">TtDT - Report - Appendix - The standard 'Pipeline' or 'Pipe-and-Filter' Architecture</a></span></li></ul></li><li><span><a href="page5766578192.html">TtDT - Report - References</a></span></li><li><span><a href="page5766545409.html">TtDT - Report - Acknowledgements</a></span></li></ul></li></ul>
</div>
</div>
<div id="content" class="split">
<div class='wiki-page'>
<div class='wiki-title'>
<h1 class='page-title-lvl-cover' id='Bookmark56'>TtDT - Report - Building resilient dataset transformation transparency</h1>
</div>
<div class='wiki-content'>
<a name="Bookmark57"></a><h1 id="Bookmark57">Introduction</h1><p>bCLEARer stage pipelines work at the level of datasets rather than dataset collections and so have a structure that offers substantially more opportunities for accounting. In this section the focus is on building transformation transparency for those datasets. </p><p>After a section setting the scene, the following topics are covered:</p><ul><li><p>firstly, a general notion of algorithmic identity, from which difference and so transformation can be established, and</p></li><li><p>secondly, how to implement transparency in the individual bCLEARer stage pipelines through tracking, tracing and testing transformations.</p></li></ul><p>The discussion of the second topic is divided into three sections:</p><ol start="1"><li><p>mapping tracking of intended identities </p></li><li><p>mapping tracing of intended changing identities</p></li><li><p>testing tracking and tracing for actual executions</p></li></ol><a name="Bookmark58"></a><h1 id="Bookmark58">Setting the scene</h1><p>The bCLEARer stage is designed as a sequence of bUnit <span class="inline-comment-marker" data-ref="175eab42-9f32-43f8-adf1-1211df4514d7">process </span>types – the bUnit flow – which may or may not be organised into sub-pipelines within the stage. It is important that this flow is not only transparent, open to inspection, but that the transparency is also resilient in the face of change. </p><p>A bUnit process type can be characterised as a type of process that consumes one or more (input) <span class="inline-comment-marker" data-ref="1bffc318-09ce-4587-a91f-806063792ffc">dataset </span>types and produces one or more new (output) <span class="inline-comment-marker" data-ref="1469d260-110b-438e-8174-ac1eff4f87ea">dataset </span>types. At this level, unlike the higher levels which work with dataset collections, dataset types are individuated, where each dataset type is picked out as separate. So process types have associated flow mappings – mappings from the individual input dataset type and to the individual output dataset type.</p><p>The components of the bUnit flow, the bUnit process and dataset types, are identified using a name, typically reflecting its function, that is unique within the bUnit, which is often supplemented with a project-wide (code) identifier. When the bUnit dataset flow is run, the run is given an identifier. The datasets and processes in the run are identified by the combination of the type identifier and the run identifier.</p><p>In the context of bUnit flow, a dataset is a collection of data items in a common format – where a data item is a single unit of data. A tabular row dataset – a common type of dataset – is a table where the data items are the rows (these rows have an internal structure/content stored in cells based upon the table's columns). Another common case is a tabular cell dataset where the data items are the table’s cells themselves. </p><p>One can visualise the bUnit flow in a number of ways. Firstly, from the perspective of the process types – see below. </p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" src="img_48.png" width="442" height="69" /></span><p>Secondly from the perspective of process and dataset types, where the pipes are adorned with a dataset icon – see below. </p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" src="img_49.png" width="442" height="90" /></span><p>And finally from a pure dataset type perspective, a bUnit dataset flow, showing a sequence of datasets – see below.</p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" src="img_50.png" width="442" height="89" /></span><a name="Bookmark59"></a><h1 id="Bookmark59">A general notion of algorithmic dataset identity</h1><p>In the bCLEARer stage pipeline design process, one defines (and so, in this scheme of things, gives identity to) bUnit dataset types and their associated bUnit filter types. In the diagram below, ‘dataset 1’ and ‘dataset 2' are bUnit dataset types associated with bUnit filter type 'filter A’. These names help humans keep track of the identities for the bUnit datasets and process types. In the implementation there will be internal identifiers corresponding to these for the computer to use.</p><span class="confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size"><img class="confluence-embedded-image image-center" src="img_51.png" width="442" height="90" /></span><p>Filters are where transformations happen. From the perspective of datasets, we can be more specific and locate it as a property of the relation between a filter's input dataset and output dataset – a filter-dataset flow. This is perhaps more easily visualised when the flow is seen from the dataset perspective, as in the diagram below. </p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="img_52.png" /></span><p>So the starting point for inspecting dataset transformations is these filter-dataset flows. To make them more concrete we can list them in a table – as done below. </p><div class="table-wrap"><table data-local-id="72cdfdaf-d8a3-4dd4-9526-d7826666e9b4" data-layout="default" class="confluenceTable" style="font-size:1.0em"><colgroup><col style="width: 256.0px;" /><col style="width: 252.0px;" /><col style="width: 252.0px;" /></colgroup><tbody><tr><th class="confluenceTh"><p><strong>bUnit process</strong></p></th><th class="confluenceTh"><p><strong>bUnit input</strong></p></th><th class="confluenceTh"><p><strong>bUnit output</strong></p></th></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>filter A</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 1</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 2</p></td></tr></tbody></table></div><p>To enable tracking and tracing of dataset transformations one firstly needs to identify the types of dataset identities that are to be tracked and traced. Then one can ask for their filter-dataset flows, showing where these identities are preserved.</p><p>The two core types of algorithmic dataset identity bCLEARer works with at the moment are:</p><ol start="1"><li><p>dataset item identity</p></li><li><p>dataset item immutable stage identity</p></li></ol><p>As these are all algorithmic identities, they can be tested automatically. bCLEARer implements these algorithms using <span class="inline-comment-marker" data-ref="71b21519-489a-48cf-b05d-c6bda4d127a2">counts</span>, sums and hashes (which are described here: <a data-linked-resource-id="5768839184" data-linked-resource-version="4" data-linked-resource-type="page" href="page5768839184.html#Bookmark95" title="TtDT - Report - Appendix - bH - bHashing and bSumming">TtDT - Report - Appendix - bH - bHashing and bSumming</a>) and stores them as metadata on all the bUnit datasets. This makes it easy to test for unexpected differences.</p><p>These identities are described below.</p><a name="Bookmark60"></a><h2 id="Bookmark60">Dataset item identity</h2><p>The first type of algorithmic identity is dataset item identity. This is based upon immutability of the collected data items' identities. In a bUnit filter where an input dataset type is intended to have a corresponding output dataset type that collects exactly the ‘same’ data items – where sameness is based upon data item identity – then they share dataset item identity. <span class="inline-comment-marker" data-ref="468ba323-fa04-4fe1-bde1-d015643f9d2f">The content of the data items may change – for example, a column may be dropped – but this does not affect the dataset identity</span>. However, a merge or split of a dataset, where the collected data items change will not qualify for dataset item identity.</p><p>Reconsider the example above. Assume we intend that filter A preserves dataset item identity, then we could record the transformation characteristics to the filter-dataset flow as shown in the table below. </p><div class="table-wrap"><table data-local-id="f1215593-5df7-48ed-959c-a3f99fbc2b72" data-layout="default" class="confluenceTable" style="font-size:0.9em"><colgroup><col style="width: 186.0px;" /><col style="width: 193.0px;" /><col style="width: 176.0px;" /><col style="width: 205.0px;" /></colgroup><tbody><tr><th class="confluenceTh"><p><strong>bUnit process</strong></p></th><th class="confluenceTh"><p><strong>bUnit input</strong></p></th><th class="confluenceTh"><p><strong>bUnit output</strong></p></th><th class="confluenceTh"><p><strong>identity</strong></p></th></tr><tr><td class="confluenceTd" style="padding:0.45em"><p>filter A</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 1</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 2</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset item identity</p></td></tr></tbody></table></div><p>Where a filter-dataset flow has this characteristic, when it is executed we test the identity. Where there is a difference, this is reported and should be investigated – we discuss this further in the testing section below.</p><p>Of course, it is possible that there are multiple item identities that that dataset is tracking, but we only consider the case where there is one here.</p><a name="Bookmark61"></a><h2 id="Bookmark61">Dataset item immutable stage identity</h2><p>The second type of algorithmic identity is dataset item immutable stage identity – this is based upon immutability of the collected data items' content (including their identities). This follows a similar pattern to the identity described above.</p><p>In a bUnit filter, such as a pass-through, where an input dataset is intended to have a corresponding output dataset type that collects exactly the ‘same’ data items with their content unchanged – then they share dataset item immutable stage identity. In this case, dropping a column from the dataset would change the contents, so they wouldn’t share this identity.  This can be regarded as a more stringent kind of dataset item identity – as dataset item immutable stage identity implies d<span class="inline-comment-marker" data-ref="40136bc2-6226-481d-b34f-acfb29b868ee">ataset item identity.</span> </p><p>Reconsider again the filter A example. Assume we now intend filter A to preserve dataset item immutable stage identity, then we could record the transformation characteristics to the filter-dataset flow as shown in the table below. </p><div class="table-wrap"><table data-local-id="ea6233d7-7673-4593-92fe-e51ddfe4c9fe" data-layout="default" class="confluenceTable" style="font-size:0.9em"><colgroup><col style="width: 146.0px;" /><col style="width: 134.0px;" /><col style="width: 155.0px;" /><col style="width: 325.0px;" /></colgroup><tbody><tr><th class="confluenceTh"><p><strong>bUnit process</strong></p></th><th class="confluenceTh"><p><strong>bUnit input</strong></p></th><th class="confluenceTh"><p><strong>bUnit output</strong></p></th><th class="confluenceTh"><p><strong>identity</strong></p></th></tr><tr><td class="confluenceTd" style="padding:0.45em"><p>filter A</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 1</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 2</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset item immutable stage identity</p></td></tr></tbody></table></div><p>Where a filter-dataset flow has this characteristic, when the pipeline is executed we test for this identity. Where there is a difference, this is reported and should be investigated – we discuss this further in the testing section below. In practice, we will need to differentiate between cases where we expect the dataset and associated data items' identity to always change and where they may change, but don’t necessarily. in this exposition we gloss over this distinction.</p><p>Where a dataset is processed and the input and output versions both collect the ‘same’ data items with the same content, then they are the same dataset immutable stage. Where the content of a data item changes – for example, a column is dropped – this marks the end of the dataset immutable stage but does not affect the dataset identity. </p><p>The obvious candidate for stage identity based upon content immutability is the maximal content of the dataset. For example, in the case of tables, this would be all the data columns. There will be cases where the content naturally divides into sub-content and so can be usefully tracked in finer detail. However we only consider the case where there is a single (maximal) notion of content here.</p><a name="Bookmark62"></a><h1 id="Bookmark62">Tracking intended dataset identities</h1><p>In this context, tracking means following the intended flow of the two identities through the bUnit pipeline. In other words, for a particular dataset identity, which bUnit datasets (pipes) it is intended to pass through. This involves mapping where it is intended to be preserved across bUnit filters. We describe this in more detail in this section.</p><a name="Bookmark63"></a><h2 id="Bookmark63">Tracking a simple pass-through </h2><p>Consider first a simple pass-through pipeline visualised in the figure below.<br /></p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="img_53.png" /></span><p>This gives rise to the filter-dataset transformation characteristics in the table below.</p><div class="table-wrap"><table data-local-id="3ee568bf-066b-405a-82e9-6a469d244621" data-layout="default" class="confluenceTable" style="font-size:0.9em"><colgroup><col style="width: 143.0px;" /><col style="width: 121.0px;" /><col style="width: 157.0px;" /><col style="width: 339.0px;" /></colgroup><tbody><tr><th class="confluenceTh"><p><strong>bUnit process</strong></p></th><th class="confluenceTh"><p><strong>bUnit input</strong></p></th><th class="confluenceTh"><p><strong>bUnit output</strong></p></th><th class="confluenceTh"><p><strong>identity level</strong></p></th></tr><tr><td class="confluenceTd" style="padding:0.45em"><p>pass-through</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 1</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 2</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset item identity</p></td></tr><tr><td class="confluenceTd" style="padding:0.45em"><p>pass-through</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 1</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 2</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset item immutable stage identity</p></td></tr></tbody></table></div><p>From this table we can infer that there is a dataset, of which dataset 1 and dataset 2 are bUnit filter stages – dataset A. We can also infer that this dataset is its own immutable stage, as it is immutable throughout its life. <span class="inline-comment-marker" data-ref="5540785e-031a-47dc-b3ca-8c95d2760652">This means it has two names</span>. We tend to use the shorter names in diagrams and have both in one of the tables for reference (here you can find both names in a later table). This structure can be visualised as a <span class="inline-comment-marker" data-ref="850b5d6b-92b5-4ca4-8b60-05fd84f32477">tracking life history</span> – as shown in the figure below.<br /></p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="img_54.png" /></span><p>The tracking is recorded in the component structure. In this case, where the bUnit dataset is a stage in the life of the larger dataset. This structure can be recorded in a tracking table, such as the one below.</p><div class="table-wrap"><table data-local-id="2345f9a0-54aa-42c0-880a-72284bb5f566" data-layout="default" class="confluenceTable" style="font-size:1.0em"><colgroup><col style="width: 360.0px;" /><col style="width: 400.0px;" /></colgroup><tbody><tr><th class="confluenceTh"><p><strong>composite</strong></p></th><th class="confluenceTh"><p><strong>tracked component </strong></p></th></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>dataset A</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 1 / dataset A bUnit stage dataset 1</p></td></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>dataset A</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 2 / dataset A bUnit stage dataset 2</p></td></tr></tbody></table></div><p><span class="inline-comment-marker" data-ref="e41f3a97-f634-447e-80d0-f930a83e5825">The stage succession structure can also be recorded in a table</span></p><div class="table-wrap"><table data-local-id="279f048f-b326-4ad6-85cf-4b54b707261f" data-layout="default" class="confluenceTable" style="font-size:1.0em"><colgroup><col style="width: 321.0px;" /><col style="width: 325.0px;" /><col style="width: 114.0px;" /></colgroup><tbody><tr><th class="confluenceTh"><p><strong>before</strong></p></th><th class="confluenceTh"><p><strong>after</strong></p></th><th class="confluenceTh"><p><strong>type</strong></p></th></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>dataset 1 / dataset A bUnit stage dataset 1</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 2 / dataset A bUnit stage dataset 2</p></td><td class="confluenceTd" style="padding:0.5em"><p>bUnit stage</p></td></tr></tbody></table></div><a name="Bookmark64"></a><h1 id="Bookmark64">Tracing intended dataset identities</h1><p>In this context, tracing means identifying the intended flow of transformation based upon multiple tracked identities. This involves mapping where the bUnit filters intend a transformation. We describe this in more detail in this section.</p><a name="Bookmark65"></a><h3 id="Bookmark65">Tracing simple dataset stage successions</h3><p>It can be intended that a dataset remain immutable throughout its life. Or, it can be intended that datasets can change (be mutable). In the bCLEARer stage pipeline, the changes translate into a series of immutable stages.  The tracing marks out the sequence of stages.</p><p>Consider the simple single filter pipeline in the figure below.<br /></p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="img_55.png" /></span><p>Assume filter A preserves dataset identity, but transforms the content (in some way). This gives rise to the mapping table below.</p><div class="table-wrap"><table data-local-id="47db6531-4dc4-436a-a377-d8d53f6a9944" data-layout="default" class="confluenceTable" style="font-size:0.9em"><colgroup><col style="width: 238.0px;" /><col style="width: 174.0px;" /><col style="width: 174.0px;" /><col style="width: 174.0px;" /></colgroup><tbody><tr><th class="confluenceTh"><p><strong>bUnit process</strong></p></th><th class="confluenceTh"><p><strong>bUnit input</strong></p></th><th class="confluenceTh"><p><strong>bUnit output</strong></p></th><th class="confluenceTh"><p><strong>identity level</strong></p></th></tr><tr><td class="confluenceTd" style="padding:0.45em"><p>filter A</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 1</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 2</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset item identity</p></td></tr></tbody></table></div><p>From this one can infer the existence of dataset A and its two immutable stages that are identical with their corresponding bUnit datasets. We can record this in an existence table like that below.</p><div class="table-wrap"><table data-local-id="41b416cd-6ebf-4b1a-b92a-aec1493ee0a7" data-layout="default" class="confluenceTable" style="font-size:1.0em"><colgroup><col style="width: 244.0px;" /><col style="width: 516.0px;" /></colgroup><tbody><tr><th class="confluenceTh"><p><strong>Identity dataset</strong></p></th><th class="confluenceTh"><p><strong>component</strong></p></th></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>dataset W</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 1 / dataset W immutable bUnit stage dataset 1</p></td></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>dataset W</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 2 / dataset W immutable bUnit stage dataset 2</p></td></tr></tbody></table></div><p>For tracing purposes, one also needs to identify the succession transformation. This can be inferred algorithmically from the previous tables. One can record them in an succession table like that below.</p><div class="table-wrap"><table data-local-id="0ea57d92-5596-43f7-a739-5950e4c2a963" data-layout="default" class="confluenceTable" style="font-size:1.0em"><colgroup><col style="width: 323.0px;" /><col style="width: 319.0px;" /><col style="width: 118.0px;" /></colgroup><tbody><tr><th class="confluenceTh"><p><strong>prior dataset stage</strong></p></th><th class="confluenceTh"><p><strong>post dataset stage</strong></p></th><th class="confluenceTh"><p><strong>bUnit process</strong></p></th></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>dataset W immutable bUnit stage dataset 1</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset W immutable bUnit stage dataset 2</p></td><td class="confluenceTd" style="padding:0.5em"><p>filter A</p></td></tr></tbody></table></div><p>This trace can be shown visually in a life history.<br /></p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="img_56.png" /></span><a name="Bookmark66"></a><h2 id="Bookmark66">Tracing simple dataset successions</h2><p>Consider a simple single filter pipeline whose bUnit filter is designed to take a dataset as input and output, based upon this, a different dataset. Then the dataset identity table is empty, as no identities are preserved. But there is an intended transformation, the emergence of a new dataset, that needs to be traced. </p><p>Reconsider the pipeline in the figure above. In this example, assume dataset 2 is a new dataset, different from dataset 1. In this simple case, the bUnit dataset flow links the two (distinct) bUnit datasets.</p><p>For tracing purposes one also needs to identify the dataset emergence transformation – the links from the emerging dataset back to the dataset it is immediately dependent upon. This can be inferred algorithmically from the filter and recorded in an mapping table like that below.</p><div class="table-wrap"><table data-local-id="c9556786-4018-44f6-b62e-7b11620af917" data-layout="default" class="confluenceTable" style="font-size:1.0em"><colgroup><col style="width: 256.0px;" /><col style="width: 252.0px;" /><col style="width: 252.0px;" /></colgroup><tbody><tr><th class="confluenceTh"><p><strong>prior dataset </strong></p></th><th class="confluenceTh"><p><strong>post dataset </strong></p></th><th class="confluenceTh"><p><strong>bUnit process</strong></p></th></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>dataset 1</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 2</p></td><td class="confluenceTd" style="padding:0.5em"><p>filter A</p></td></tr></tbody></table></div><p>This trace can be shown visually in a life history.<br /></p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="img_57.png" /></span><a name="Bookmark67"></a><h2 id="Bookmark67">Tracking and tracing branches</h2><p>The bCLEARer stage pipeline flow can split-and-merge, which creates the possibility for the dataset identities to split and merge as well. Consider the pipeline in the figure below. <br /></p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="img_58.png" /></span><p>Assume the filters (whatever they are) just preserve data item identity, so not immutable stage identity. This gives rise to the mapping table below.</p><div class="table-wrap"><table data-local-id="3d8bb2ab-a695-47d4-8247-0c1398e5f811" data-layout="default" class="confluenceTable" style="font-size:0.9em"><colgroup><col style="width: 238.0px;" /><col style="width: 174.0px;" /><col style="width: 174.0px;" /><col style="width: 174.0px;" /></colgroup><tbody><tr><th class="confluenceTh"><p><strong>bUnit process</strong></p></th><th class="confluenceTh"><p><strong>bUnit input</strong></p></th><th class="confluenceTh"><p><strong>bUnit output</strong></p></th><th class="confluenceTh"><p><strong>identity level</strong></p></th></tr><tr><td class="confluenceTd" style="padding:0.45em"><p>filter X</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 1</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 2</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset item identity</p></td></tr><tr><td class="confluenceTd" style="padding:0.45em"><p>filter Y</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 1</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 3</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset item identity</p></td></tr><tr><td class="confluenceTd" style="padding:0.45em"><p>filter Z</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 2</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 4</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset item identity</p></td></tr><tr><td class="confluenceTd" style="padding:0.45em"><p>filter Z</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 3</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset 4</p></td><td class="confluenceTd" style="padding:0.45em"><p>dataset item identity</p></td></tr></tbody></table></div><p>The lack of dataset item immutable stage identity implies that there is a dataset item immutable stage difference. The dataset item identity implies the existence of a dataset persisting through the bUnit dataset flow – dataset A – of which the bUnit datasets are components – as shown in the table below.</p><div class="table-wrap"><table data-local-id="5706e85a-b242-4caa-958c-eeff0a85f103" data-layout="default" class="confluenceTable" style="font-size:1.0em"><colgroup><col style="width: 167.0px;" /><col style="width: 593.0px;" /></colgroup><tbody><tr><th class="confluenceTh"><p><strong>composite</strong></p></th><th class="confluenceTh"><p><strong>component</strong></p></th></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>dataset A</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 1 / dataset A immutable bUnit stage dataset 1</p></td></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>dataset A</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 2 / dataset A immutable bUnit stage dataset 2</p></td></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>dataset A</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 3 / dataset A immutable bUnit stage dataset 3</p></td></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>dataset A</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 4 / dataset A immutable bUnit stage dataset 4</p></td></tr></tbody></table></div><p>The earlier mapping table <span class="inline-comment-marker" data-ref="889c8a95-14d3-4c32-ac95-1285b090613c">provide </span>the basis for immutable stage tracing relations between the bUnit datasets. The resulting life history below visualises the tracking – using components, and tracing – using arrows.  </p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="img_59.png" /></span><p>Or it can be recorded in a table, such as the one below.</p><div class="table-wrap"><table data-local-id="d773b2a1-5989-4db3-86d7-9105d633f0b4" data-layout="default" class="confluenceTable" style="font-size:1.0em"><colgroup><col style="width: 279.0px;" /><col style="width: 481.0px;" /></colgroup><tbody><tr><th class="confluenceTh"><p><strong>composite</strong></p></th><th class="confluenceTh"><p><strong>tracked component</strong></p></th></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>dataset A</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 1 / dataset A immutable bUnit stage 1</p></td></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>dataset A</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 2 / dataset A immutable bUnit stage 2</p></td></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>dataset A</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 3 / dataset A immutable bUnit stage 3</p></td></tr><tr><td class="confluenceTd" style="padding:0.5em"><p>dataset A</p></td><td class="confluenceTd" style="padding:0.5em"><p>dataset 4 / dataset A immutable bUnit stage 4</p></td></tr></tbody></table></div><p>There are successions between the bUnit dataset stages. These are identified and recorded as part of tracing<span class="inline-comment-marker" data-ref="77769a03-be20-42a2-8c08-ab2220a2656c">, which is the topic of the next section.</span></p><a name="Bookmark68"></a><h1 id="Bookmark68">Testing identity </h1><p>Once the intended tracks and traces have been identified (as described in the two previous sections), they can be used when the pipeline is executed to test whether identity is being preserved as intended. The pipeline has been implemented so that every bUnit dataset has immutable metadata; a count, hashsums for item identity and immutable stage identity, and a hash for bUnit stage identity. Each bUnit filter has a corresponding inspection filter that has access to its dataset’s metadata. This is shown graphically in the figure below.</p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="img_60.png" /></span><p>The inspection filter uses the dataset metadata as the basis for testing, as described in the next sections.</p><a name="Bookmark69"></a><h2 id="Bookmark69">Testing a simple pass through</h2><p>Assume we have a simple pass-though filter as discussed earlier and shown in the figure below. As it is a pass through, dataset and immutable stage identity are preserved, as shown in the life history.</p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="img_61.png" /></span><p>In the pipeline, the associated inspection process has access to the dataset metadata – as shown in the figure below.</p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="img_62.png" /></span><p>It uses the track and trace maps to test the transformations. In this case, all non-bUnit items of metadata should match (bUnit stage identities should never match).</p><a name="Bookmark70"></a><h2 id="Bookmark70">Testing a simple column drop</h2><p>Now assume we have a simple filter where the dataset has its content transformed – by, for example, dropping a column or two. In this case, dataset identity is preserved, but immutable stage identity is not, as shown in the life history.</p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="img_63.png" /></span><p>In the pipeline, the associated inspection filter has access to the dataset metadata – as shown in the figure below.</p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="img_64.png" /></span><p>It uses the track and trace mapping to test the transformations. In this case, only the first item of metadata (identity_hashsum) should match.</p><a name="Bookmark71"></a><h2 id="Bookmark71">Testing a simple dataset split</h2><p>Testing splits <span class="inline-comment-marker" data-ref="60fd11a1-5f4a-46e8-83c2-292ad1e4776f">(and merges - see below)</span> requires a little more calculation than simple matching. Consider the split shown in the figure below. In this case, the sum of the two output items should match the input items.</p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="img_65.png" /></span><p></p><a name="Bookmark72"></a><h2 id="Bookmark72">Testing a simple dataset merge </h2><p><span class="inline-comment-marker" data-ref="b388953a-20a7-495f-bde0-e840d0f64d17">Consider the merge shown in the figure below. In this case, the input items should match the sum of the two output items.</span></p><span class="confluence-embedded-file-wrapper image-center-wrapper"><img class="confluence-embedded-image image-center" src="img_66.png" /></span><a name="Bookmark73"></a><h2 id="Bookmark73">Expanding the testing</h2><p>We have only covered a small range of the possible tests that can be done with bCLEARer stage pipelines. But hopefully this is enough to give a good idea of the kinds of test that are feasible. </p>
</div>
</div>
</div>
</div>
<script>
Split(['#sidebar', '#content'], {
    sizes: [15, 85],
    minSize: 100
});
</script>

</body>
</html>
